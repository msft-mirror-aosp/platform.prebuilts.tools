diff --git a/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt b/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt
index 678d2fc6beed..f7996d27104e 100644
--- a/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt
+++ b/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt
@@ -238,7 +238,15 @@ private class AnonymousTypesSubstitutor(
         if (type !is ConeClassLikeType) return null
 
         val hasStableName = type.classId?.isLocal == true
-        if (!hasStableName) return null
+        if (!hasStableName) {
+            // Make sure we're not going to expand type argument over and over again.
+            // If so, i.e., if there is a recursive type argument, return the current, non-null [type]
+            // to prevent the following [substituteTypeOr*] from proceeding to its own (recursive) substitution.
+            if (type.hasRecursiveTypeArgument()) return type
+            // Return `null` means we will use [fir.resolve.substitution.Substitutors]'s [substituteRecursive]
+            // that literally substitutes type arguments recursively.
+            return null
+        }
 
         val firClassNode = type.lookupTag.toSymbol(session) as? FirClassSymbol
         if (firClassNode != null) {
@@ -248,4 +256,21 @@ private class AnonymousTypesSubstitutor(
         return if (type.nullability.isNullable) session.builtinTypes.nullableAnyType.type
         else session.builtinTypes.anyType.type
     }
+
+    private fun ConeKotlinType.hasRecursiveTypeArgument(
+        visited: MutableSet<ConeKotlinType> = mutableSetOf()
+    ): Boolean {
+        if (typeArguments.isEmpty()) return false
+        visited.add(this)
+        for (projection in typeArguments) {
+            // E.g., Test : Comparable<Test>
+            val type = (projection as? ConeKotlinTypeProjection)?.type ?: continue
+            // E.g., Comparable<Test>
+            val newType = substituteOrNull(type) ?: continue
+            if (newType in visited) return true
+            // Visit new type: e.g., Test, as a type argument, is substituted with Comparable<Test>, again.
+            if (newType.hasRecursiveTypeArgument(visited)) return true
+        }
+        return false
+    }
 }
diff --git a/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt b/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt
index 0fa65625b927..a863d418cff1 100644
--- a/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt
+++ b/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt
@@ -13,6 +13,7 @@ import com.intellij.ide.highlighter.JavaFileType
 import com.intellij.mock.MockProject
 import com.intellij.openapi.Disposable
 import com.intellij.openapi.roots.PackageIndex
+import com.intellij.openapi.util.io.FileUtil
 import com.intellij.openapi.vfs.VirtualFile
 import com.intellij.openapi.vfs.VirtualFileManager
 import com.intellij.psi.PsiDirectory
@@ -50,7 +51,7 @@ object StandaloneProjectFactory {
         compilerConfiguration: CompilerConfiguration = CompilerConfiguration(),
     ): KotlinCoreProjectEnvironment {
         val applicationEnvironment =
-            KotlinCoreEnvironment.getOrCreateApplicationEnvironmentForTests(applicationDisposable, compilerConfiguration)
+            KotlinCoreEnvironment.getOrCreateApplicationEnvironmentForProduction(applicationDisposable, compilerConfiguration)
 
         return KotlinCoreProjectEnvironment(projectDisposable, applicationEnvironment).apply {
             registerJavaPsiFacade(project)
@@ -212,7 +213,7 @@ object StandaloneProjectFactory {
         environment: KotlinCoreProjectEnvironment
     ): List<VirtualFile> {
         return roots.mapNotNull { path ->
-            val pathString = path.toAbsolutePath().toString()
+            val pathString = FileUtil.toSystemIndependentName(path.toAbsolutePath().toString())
             when {
                 pathString.endsWith(JAR_PROTOCOL) -> {
                     environment.environment.jarFileSystem.findFileByPath(pathString + JAR_SEPARATOR)
@@ -294,4 +295,4 @@ object StandaloneProjectFactory {
 
     private val latestLanguageVersionSettings: LanguageVersionSettings =
         LanguageVersionSettingsImpl(LanguageVersion.LATEST_STABLE, ApiVersion.LATEST)
-}
\ No newline at end of file
+}
diff --git a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt
index d4e00ad5a859..ec795e30202a 100644
--- a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt
+++ b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt
@@ -125,9 +125,7 @@ abstract class SymbolLightClassBase protected constructor(val ktModule: KtModule
 
     abstract override fun hashCode(): Int
 
-    override fun getContext(): PsiElement = parent ?: buildErrorWithAttachment("parent must not be null") {
-        withClassEntry("class", this@SymbolLightClassBase)
-    }
+    override fun getContext(): PsiElement? = parent
 
     override fun isEquivalentTo(another: PsiElement?): Boolean = PsiClassImplUtil.isClassEquivalentTo(this, another)

diff --git a/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt b/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt
index 25bc52c2eb3d..7cdc214072c9 100644
--- a/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt
+++ b/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt
@@ -81,7 +81,9 @@ class FirJvmTypeMapper(val session: FirSession) : FirSessionComponent {
 
         override fun getClassInternalName(typeConstructor: TypeConstructorMarker): String {
             require(typeConstructor is ConeClassLikeLookupTag)
-            return typeConstructor.classId.asString().replace(".", "$").replace("/", ".")
+            val classId = typeConstructor.classId
+            val name = if (classId.isLocal) safeShortClassName(classId) else classId.asString()
+            return name.replace(".", "$").replace("/", ".")
         }
 
         override fun getScriptInternalName(typeConstructor: TypeConstructorMarker): String =
@@ -228,7 +230,11 @@ class FirJvmTypeMapper(val session: FirSession) : FirSessionComponent {
         val result = runUnless(classId.isLocal) {
             classId.asSingleFqName().toUnsafe().let { JavaToKotlinClassMap.mapKotlinToJava(it)?.shortClassName?.asString() }
         }
-        return result ?: SpecialNames.safeIdentifier(classId.shortClassName).identifier
+        return result ?: safeShortClassName(classId)
+    }
+
+    private fun safeShortClassName(classId: ClassId): String {
+        return SpecialNames.safeIdentifier(classId.shortClassName).identifier
     }
 }

diff --git a/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt b/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt
index 83873e4941b8..33ca84369b63 100644
--- a/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt
+++ b/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt
@@ -121,7 +121,12 @@ internal fun PsiElement.getNonLocalContainingOrThisDeclaration(predicate: (KtDec
 
     for (parent in parentsWithSelf) {
         candidate?.let { notNullCandidate ->
-            if (parent is KtEnumEntry || parent is KtCallableDeclaration && !notNullCandidate.isPartOf(parent) || parent is KtClassInitializer) {
+            if (parent is KtEnumEntry ||
+                parent is KtCallableDeclaration && !notNullCandidate.isPartOf(parent) ||
+                parent is KtClassInitializer ||
+                parent is KtObjectLiteralExpression ||
+                parent is KtCallElement
+            ) {
                 // Candidate turned out to be local. Let's find another one.
                 candidate = null
             }
diff --git a/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt b/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt
index c177b4faecb1..47feb7aaa574 100644
--- a/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt
+++ b/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt
@@ -6,6 +6,7 @@
 package org.jetbrains.kotlin.analysis.api.impl.base.util
 
 import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.io.FileUtil
 import com.intellij.openapi.util.text.StringUtil
 import com.intellij.openapi.vfs.StandardFileSystems
 import com.intellij.openapi.vfs.VfsUtilCore
@@ -116,7 +117,9 @@ object LibraryUtils {
         val result = mutableListOf<String>()
 
         if (isModularRuntime(jdkHome)) {
-            val jrtBaseUrl: String = StandardFileSystems.JRT_PROTOCOL_PREFIX + jdkHome.toString() + JAR_SEPARATOR
+            val jrtBaseUrl = "${StandardFileSystems.JRT_PROTOCOL_PREFIX}${
+                FileUtil.toSystemIndependentName(jdkHome.toAbsolutePath().toString())
+            }$JAR_SEPARATOR"
             val modules = readModulesFromReleaseFile(jdkHome)
             if (modules != null) {
                 for (module in modules) {
diff --git a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt
index 41151108578f..36100284e125 100644
--- a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt
+++ b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt
@@ -57,7 +57,6 @@ internal object PsiDeclarationAndKtSymbolEqualityChecker {
         val offset = if (symbol.isExtension) 1 else 0
         symbol.valueParameters.forEachIndexed { index, valueParameterSymbol ->
             val psiParameter = psi.parameterList.parameters[index + offset]
-            if (valueParameterSymbol.name.asString() != psiParameter.name) return false
             if (valueParameterSymbol.isVararg != psiParameter.isVarArgs) return false
             if (!isTheSameTypes(
                     psi,
