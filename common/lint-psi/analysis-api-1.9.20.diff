diff --git a/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt b/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt
index 678d2fc6beed..f7996d27104e 100644
--- a/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt
+++ b/analysis/analysis-api-fir/src/org/jetbrains/kotlin/analysis/api/fir/components/KtFirPsiTypeProvider.kt
@@ -238,7 +238,15 @@ private class AnonymousTypesSubstitutor(
         if (type !is ConeClassLikeType) return null
 
         val hasStableName = type.classId?.isLocal == true
-        if (!hasStableName) return null
+        if (!hasStableName) {
+            // Make sure we're not going to expand type argument over and over again.
+            // If so, i.e., if there is a recursive type argument, return the current, non-null [type]
+            // to prevent the following [substituteTypeOr*] from proceeding to its own (recursive) substitution.
+            if (type.hasRecursiveTypeArgument()) return type
+            // Return `null` means we will use [fir.resolve.substitution.Substitutors]'s [substituteRecursive]
+            // that literally substitutes type arguments recursively.
+            return null
+        }
 
         val firClassNode = type.lookupTag.toSymbol(session) as? FirClassSymbol
         if (firClassNode != null) {
@@ -248,4 +256,21 @@ private class AnonymousTypesSubstitutor(
         return if (type.nullability.isNullable) session.builtinTypes.nullableAnyType.type
         else session.builtinTypes.anyType.type
     }
+
+    private fun ConeKotlinType.hasRecursiveTypeArgument(
+        visited: MutableSet<ConeKotlinType> = mutableSetOf()
+    ): Boolean {
+        if (typeArguments.isEmpty()) return false
+        visited.add(this)
+        for (projection in typeArguments) {
+            // E.g., Test : Comparable<Test>
+            val type = (projection as? ConeKotlinTypeProjection)?.type ?: continue
+            // E.g., Comparable<Test>
+            val newType = substituteOrNull(type) ?: continue
+            if (newType in visited) return true
+            // Visit new type: e.g., Test, as a type argument, is substituted with Comparable<Test>, again.
+            if (newType.hasRecursiveTypeArgument(visited)) return true
+        }
+        return false
+    }
 }
diff --git a/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt b/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt
index 0fa65625b927..a863d418cff1 100644
--- a/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt
+++ b/analysis/analysis-api-standalone/analysis-api-standalone-base/src/org/jetbrains/kotlin/analysis/api/standalone/base/project/structure/StandaloneProjectFactory.kt
@@ -13,6 +13,7 @@ import com.intellij.ide.highlighter.JavaFileType
 import com.intellij.mock.MockProject
 import com.intellij.openapi.Disposable
 import com.intellij.openapi.roots.PackageIndex
+import com.intellij.openapi.util.io.FileUtil
 import com.intellij.openapi.vfs.VirtualFile
 import com.intellij.openapi.vfs.VirtualFileManager
 import com.intellij.psi.PsiDirectory
@@ -50,7 +51,7 @@ object StandaloneProjectFactory {
         compilerConfiguration: CompilerConfiguration = CompilerConfiguration(),
     ): KotlinCoreProjectEnvironment {
         val applicationEnvironment =
-            KotlinCoreEnvironment.getOrCreateApplicationEnvironmentForTests(applicationDisposable, compilerConfiguration)
+            KotlinCoreEnvironment.getOrCreateApplicationEnvironmentForProduction(applicationDisposable, compilerConfiguration)
 
         return KotlinCoreProjectEnvironment(projectDisposable, applicationEnvironment).apply {
             registerJavaPsiFacade(project)
@@ -212,7 +213,7 @@ object StandaloneProjectFactory {
         environment: KotlinCoreProjectEnvironment
     ): List<VirtualFile> {
         return roots.mapNotNull { path ->
-            val pathString = path.toAbsolutePath().toString()
+            val pathString = FileUtil.toSystemIndependentName(path.toAbsolutePath().toString())
             when {
                 pathString.endsWith(JAR_PROTOCOL) -> {
                     environment.environment.jarFileSystem.findFileByPath(pathString + JAR_SEPARATOR)
@@ -294,4 +295,4 @@ object StandaloneProjectFactory {
 
     private val latestLanguageVersionSettings: LanguageVersionSettings =
         LanguageVersionSettingsImpl(LanguageVersion.LATEST_STABLE, ApiVersion.LATEST)
-}
\ No newline at end of file
+}
diff --git a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt
index d4e00ad5a859..ec795e30202a 100644
--- a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt
+++ b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/light/classes/symbol/classes/SymbolLightClassBase.kt
@@ -125,9 +125,7 @@ abstract class SymbolLightClassBase protected constructor(val ktModule: KtModule
 
     abstract override fun hashCode(): Int
 
-    override fun getContext(): PsiElement = parent ?: buildErrorWithAttachment("parent must not be null") {
-        withClassEntry("class", this@SymbolLightClassBase)
-    }
+    override fun getContext(): PsiElement? = parent
 
     override fun isEquivalentTo(another: PsiElement?): Boolean = PsiClassImplUtil.isClassEquivalentTo(this, another)

diff --git a/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt b/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt
index 25bc52c2eb3d..7cdc214072c9 100644
--- a/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt
+++ b/compiler/fir/fir2ir/jvm-backend/src/org/jetbrains/kotlin/fir/backend/jvm/FirJvmTypeMapper.kt
@@ -81,7 +81,9 @@ class FirJvmTypeMapper(val session: FirSession) : FirSessionComponent {
 
         override fun getClassInternalName(typeConstructor: TypeConstructorMarker): String {
             require(typeConstructor is ConeClassLikeLookupTag)
-            return typeConstructor.classId.asString().replace(".", "$").replace("/", ".")
+            val classId = typeConstructor.classId
+            val name = if (classId.isLocal) safeShortClassName(classId) else classId.asString()
+            return name.replace(".", "$").replace("/", ".")
         }
 
         override fun getScriptInternalName(typeConstructor: TypeConstructorMarker): String =
@@ -228,7 +230,11 @@ class FirJvmTypeMapper(val session: FirSession) : FirSessionComponent {
         val result = runUnless(classId.isLocal) {
             classId.asSingleFqName().toUnsafe().let { JavaToKotlinClassMap.mapKotlinToJava(it)?.shortClassName?.asString() }
         }
-        return result ?: SpecialNames.safeIdentifier(classId.shortClassName).identifier
+        return result ?: safeShortClassName(classId)
+    }
+
+    private fun safeShortClassName(classId: ClassId): String {
+        return SpecialNames.safeIdentifier(classId.shortClassName).identifier
     }
 }

diff --git a/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt b/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt
index 83873e4941b8..33ca84369b63 100644
--- a/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt
+++ b/analysis/low-level-api-fir/src/org/jetbrains/kotlin/analysis/low/level/api/fir/element/builder/FirElementBuilder.kt
@@ -121,7 +121,12 @@ internal fun PsiElement.getNonLocalContainingOrThisDeclaration(predicate: (KtDec
 
     for (parent in parentsWithSelf) {
         candidate?.let { notNullCandidate ->
-            if (parent is KtEnumEntry || parent is KtCallableDeclaration && !notNullCandidate.isPartOf(parent) || parent is KtClassInitializer) {
+            if (parent is KtEnumEntry ||
+                parent is KtCallableDeclaration && !notNullCandidate.isPartOf(parent) ||
+                parent is KtClassInitializer ||
+                parent is KtObjectLiteralExpression ||
+                parent is KtCallElement
+            ) {
                 // Candidate turned out to be local. Let's find another one.
                 candidate = null
             }
diff --git a/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt b/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt
index c177b4faecb1..47feb7aaa574 100644
--- a/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt
+++ b/analysis/analysis-api-impl-base/src/org/jetbrains/kotlin/analysis/api/impl/base/util/LibraryUtils.kt
@@ -6,6 +6,7 @@
 package org.jetbrains.kotlin.analysis.api.impl.base.util
 
 import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.io.FileUtil
 import com.intellij.openapi.util.text.StringUtil
 import com.intellij.openapi.vfs.StandardFileSystems
 import com.intellij.openapi.vfs.VfsUtilCore
@@ -116,7 +117,9 @@ object LibraryUtils {
         val result = mutableListOf<String>()
 
         if (isModularRuntime(jdkHome)) {
-            val jrtBaseUrl: String = StandardFileSystems.JRT_PROTOCOL_PREFIX + jdkHome.toString() + JAR_SEPARATOR
+            val jrtBaseUrl = "${StandardFileSystems.JRT_PROTOCOL_PREFIX}${
+                FileUtil.toSystemIndependentName(jdkHome.toAbsolutePath().toString())
+            }$JAR_SEPARATOR"
             val modules = readModulesFromReleaseFile(jdkHome)
             if (modules != null) {
                 for (module in modules) {
diff --git a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt
index 41151108578f..36100284e125 100644
--- a/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt
+++ b/analysis/symbol-light-classes/src/org/jetbrains/kotlin/analysis/providers/PsiDeclarationAndKtSymbolEqualityChecker.kt
@@ -57,7 +57,6 @@ internal object PsiDeclarationAndKtSymbolEqualityChecker {
         val offset = if (symbol.isExtension) 1 else 0
         symbol.valueParameters.forEachIndexed { index, valueParameterSymbol ->
             val psiParameter = psi.parameterList.parameters[index + offset]
-            if (valueParameterSymbol.name.asString() != psiParameter.name) return false
             if (valueParameterSymbol.isVararg != psiParameter.isVarArgs) return false
             if (!isTheSameTypes(
                     psi,
diff --git a/analysis/analysis-api-fe10/src/org/jetbrains/kotlin/analysis/api/descriptors/CliFe10AnalysisFacade.kt b/analysis/analysis-api-fe10/src/org/jetbrains/kotlin/analysis/api/descriptors/CliFe10AnalysisFacade.kt
index 267278e15fb4..dc701fd8ee3e 100644
--- a/analysis/analysis-api-fe10/src/org/jetbrains/kotlin/analysis/api/descriptors/CliFe10AnalysisFacade.kt
+++ b/analysis/analysis-api-fe10/src/org/jetbrains/kotlin/analysis/api/descriptors/CliFe10AnalysisFacade.kt
@@ -73,12 +73,15 @@ class CliFe10AnalysisFacade(private val project: Project) : Fe10AnalysisFacade {
     }
 }
 
-class KtFe10AnalysisHandlerExtension(private val useSiteModule: KtSourceModule) : AnalysisHandlerExtension {
+class KtFe10AnalysisHandlerExtension(
+    private val useSiteModule: KtSourceModule? = null
+) : AnalysisHandlerExtension {
     internal companion object {
         fun getInstance(area: AreaInstance, module: KtModule): KtFe10AnalysisHandlerExtension {
-            return AnalysisHandlerExtension.extensionPointName.getExtensions(area)
+            val extensions = AnalysisHandlerExtension.extensionPointName.getExtensions(area)
                 .filterIsInstance<KtFe10AnalysisHandlerExtension>()
-                .firstOrNull { it.useSiteModule == module }
+            return extensions.firstOrNull { it.useSiteModule == module }
+                ?: extensions.singleOrNull { it.useSiteModule == null }
                 ?: error(KtFe10AnalysisHandlerExtension::class.java.name + " should be registered")
         }
     }
@@ -109,7 +112,9 @@ class KtFe10AnalysisHandlerExtension(private val useSiteModule: KtSourceModule)
         bindingTrace: BindingTrace,
         componentProvider: ComponentProvider
     ): AnalysisResult? {
-        if (module.name.asString().removeSurrounding("<", ">") != useSiteModule.moduleName) {
+        if (useSiteModule != null &&
+            module.name.asString().removeSurrounding("<", ">") != useSiteModule.moduleName
+        ) {
             // there is no way to properly map KtModule to ModuleDescriptor,
             // KtFe10AnalysisHandlerExtension is used only for tests, so just by name comparasion should work as all module names are different
             return null
@@ -135,4 +140,4 @@ class KtFe10AnalysisHandlerExtension(private val useSiteModule: KtSourceModule)
         )
         return super.doAnalysis(project, module, projectContext, files, bindingTrace, componentProvider)
     }
-}
\ No newline at end of file
+}
diff --git a/analysis/analysis-api-providers/src/org/jetbrains/kotlin/analysis/providers/impl/KotlinStaticPackageProvider.kt b/analysis/analysis-api-providers/src/org/jetbrains/kotlin/analysis/providers/impl/KotlinStaticPackageProvider.kt
index c0c72ebde601..439b8f1a6bae 100644
--- a/analysis/analysis-api-providers/src/org/jetbrains/kotlin/analysis/providers/impl/KotlinStaticPackageProvider.kt
+++ b/analysis/analysis-api-providers/src/org/jetbrains/kotlin/analysis/providers/impl/KotlinStaticPackageProvider.kt
@@ -33,7 +33,7 @@ public class KotlinStaticPackageProvider(
     }
 
     override fun doesKotlinOnlyPackageExist(packageFqName: FqName): Boolean {
-        return packageFqName in kotlinPackageToSubPackages
+        return packageFqName.isRoot || packageFqName in kotlinPackageToSubPackages
     }
 
     override fun getKotlinOnlySubPackagesFqNames(packageFqName: FqName, nameFilter: (Name) -> Boolean): Set<Name> {
@@ -48,4 +48,4 @@ public class KotlinStaticPackageProviderFactory(
     override fun createPackageProvider(searchScope: GlobalSearchScope): KotlinPackageProvider {
         return KotlinStaticPackageProvider(project, searchScope, files)
     }
-}
\ No newline at end of file
+}
diff --git a/analysis/analysis-api-standalone/src/org/jetbrains/kotlin/analysis/project/structure/impl/KtModuleProviderImpl.kt b/analysis/analysis-api-standalone/src/org/jetbrains/kotlin/analysis/project/structure/impl/KtModuleProviderImpl.kt
index a530b258fd0f..a29b645902de 100644
--- a/analysis/analysis-api-standalone/src/org/jetbrains/kotlin/analysis/project/structure/impl/KtModuleProviderImpl.kt
+++ b/analysis/analysis-api-standalone/src/org/jetbrains/kotlin/analysis/project/structure/impl/KtModuleProviderImpl.kt
@@ -16,6 +16,7 @@ import org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.LLFirBu
 import org.jetbrains.kotlin.analysis.project.structure.*
 import org.jetbrains.kotlin.platform.TargetPlatform
 import org.jetbrains.kotlin.serialization.deserialization.builtins.BuiltInSerializerProtocol
+import org.jetbrains.kotlin.utils.KotlinExceptionWithAttachments
 
 internal class KtModuleProviderImpl(
     private val platform: TargetPlatform,
@@ -36,6 +37,7 @@ internal class KtModuleProviderImpl(
         LLFirBuiltinsSessionFactory.getInstance(project).getBuiltinsSession(platform).ktModule as KtBuiltinsModule
     }
 
+    @OptIn(KtModuleStructureInternals::class)
     override fun getKtModuleForKtElement(element: PsiElement): KtModule {
         val containingFileAsPsiFile = element.containingFile
             ?: return ktNotUnderContentRootModuleWithoutPsiFile
@@ -56,9 +58,16 @@ internal class KtModuleProviderImpl(
             return builtinsModule
         }
 
-        return mainModules.first { module ->
+        containingFileAsVirtualFile.analysisExtensionFileContextModule?.let { return it }
+
+        return mainModules.firstOrNull { module ->
             containingFileAsVirtualFile in module.contentScope
         }
+            ?: throw KotlinExceptionWithAttachments("Cannot find KtModule; see the attachment for more details.")
+                .withAttachment(
+                    containingFileAsVirtualFile.path,
+                    mainModules.joinToString(separator = System.lineSeparator()) { it.asDebugString() }
+                )
     }
 
     internal val binaryModules: List<KtBinaryModule> by lazy {
@@ -72,4 +81,19 @@ internal class KtModuleProviderImpl(
         addAll(files)
         addAll(findJvmRootsForJavaFiles(files.filterIsInstance<PsiJavaFile>()))
     }
-}
\ No newline at end of file
+}
+
+private fun KtModule.asDebugString(indent: Int = 0): String = buildString {
+    appendLine("$moduleDescription {")
+    appendLine("contentScope: $contentScope")
+    appendLine("directRegularDependencies:${System.lineSeparator()}")
+    directRegularDependencies.joinTo(this, separator = System.lineSeparator()) { dep ->
+        dep.asDebugString(indent + 1)
+    }
+    appendLine("directDependsOnDependencies:${System.lineSeparator()}")
+    directDependsOnDependencies.joinTo(this, separator = System.lineSeparator()) { dep ->
+        dep.asDebugString(indent + 1)
+    }
+    append("}")
+}.prependIndent("  ".repeat(indent))
+
