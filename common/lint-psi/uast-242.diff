diff --git a/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/KotlinUastTypeMapper.kt b/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/KotlinUastTypeMapper.kt
index 17ca6d677b52..68aecf26f38c 100644
--- a/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/KotlinUastTypeMapper.kt
+++ b/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/KotlinUastTypeMapper.kt
@@ -11,7 +11,6 @@ import org.jetbrains.kotlin.codegen.signature.AsmTypeFactory
 import org.jetbrains.kotlin.codegen.signature.JvmSignatureWriter
 import org.jetbrains.kotlin.codegen.state.isMostPreciseContravariantArgument
 import org.jetbrains.kotlin.codegen.state.isMostPreciseCovariantArgument
-import org.jetbrains.kotlin.codegen.state.updateArgumentModeFromAnnotations
 import org.jetbrains.kotlin.descriptors.*
 import org.jetbrains.kotlin.load.kotlin.TypeMappingConfiguration
 import org.jetbrains.kotlin.load.kotlin.TypeMappingMode
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
index 1a8d7bde0b1c..5b8fbb92fdc9 100644
--- a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
@@ -250,6 +250,7 @@ interface FirKotlinUastResolveProviderService : BaseKotlinUastResolveProviderSer
                 ?.symbol
                 ?.let { return toPsiMethod(it, ktElement) }
             return when (ktElement) {
+                is KtBinaryExpression,
                 is KtPrefixExpression,
                 is KtPostfixExpression -> {
                     ktCallInfo.singleCallOrNull<KtCompoundVariableAccessCall>()
@@ -268,11 +268,12 @@ interface FirKotlinUastResolveProviderService : BaseKotlinUastResolveProviderSer
             val variableAccessCall = ktSimpleNameExpression.resolveCall()?.singleCallOrNull<KtSimpleVariableAccessCall>() ?: return null
             val propertySymbol = variableAccessCall.symbol as? KtSyntheticJavaPropertySymbol ?: return null
             when (variableAccessCall.simpleAccess) {
-                is KtSimpleVariableAccess.Read ->
-                    toPsiMethod(propertySymbol.getter, ktSimpleNameExpression)
-
-                is KtSimpleVariableAccess.Write ->
-                    toPsiMethod(propertySymbol.setter ?: return null, ktSimpleNameExpression)
+                is KtSimpleVariableAccess.Read -> {
+                    toPsiMethod(propertySymbol.javaGetterSymbol, ktSimpleNameExpression)
+                }
+                is KtSimpleVariableAccess.Write -> {
+                    toPsiMethod(propertySymbol.javaSetterSymbol?: return null, ktSimpleNameExpression)
+                }
             }
         }
     }
diff --git a/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt b/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt
index 73fbfea28e6c..1bb018c3946f 100644
--- a/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt
+++ b/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt
@@ -497,7 +497,7 @@ private fun resolveContainingDeserializedClass(context: KtElement, memberDescrip
             val declaredPsiType = containingDeclaration.defaultType.toPsiType(
                 null as PsiModifierListOwner?,
                 context,
-                PsiTypeConversionConfiguration(TypeOwnerKind.DECLARATION)
+                PsiTypeConversionConfiguration(TypeOwnerKind.DECLARATION, isBoxed = true)
             )
             (declaredPsiType as? PsiClassType)?.resolve() ?: return null
         }
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt
index a98dbaff41e3c..8fb4a015074a9 100644
--- a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt
@@ -6,17 +6,23 @@ import com.intellij.openapi.project.Project
 import com.intellij.psi.*
 import com.intellij.psi.util.PsiTypesUtil
 import org.jetbrains.kotlin.analysis.api.*
+import org.jetbrains.kotlin.analysis.api.annotations.*
 import org.jetbrains.kotlin.analysis.api.calls.KtCallableMemberCall
 import org.jetbrains.kotlin.analysis.api.components.buildClassType
 import org.jetbrains.kotlin.analysis.api.lifetime.allowAnalysisFromWriteAction
 import org.jetbrains.kotlin.analysis.api.lifetime.allowAnalysisOnEdt
 import org.jetbrains.kotlin.analysis.api.symbols.*
+import org.jetbrains.kotlin.analysis.api.symbols.markers.KtAnnotatedSymbol
 import org.jetbrains.kotlin.analysis.api.types.*
 import org.jetbrains.kotlin.analysis.project.structure.KtSourceModule
 import org.jetbrains.kotlin.analysis.providers.DecompiledPsiDeclarationProvider.findPsi
 import org.jetbrains.kotlin.asJava.*
 import org.jetbrains.kotlin.asJava.classes.lazyPub
+import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
+import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget.PROPERTY_GETTER
+import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget.PROPERTY_SETTER
 import org.jetbrains.kotlin.idea.KotlinLanguage
+import org.jetbrains.kotlin.name.JvmStandardClassIds
 import org.jetbrains.kotlin.name.StandardClassIds
 import org.jetbrains.kotlin.psi.*
 import org.jetbrains.kotlin.psi.psiUtil.containingClass
@@ -98,7 +104,10 @@ internal fun toPsiMethod(
         }
     }
     return when (val psi = psiForUast(functionSymbol, context.project)) {
-        null -> null
+        null -> {
+            // Lint/UAST CLI: try `fake` creation for a deserialized declaration
+            toPsiMethodForDeserialized(functionSymbol, context, psi)
+        }
         is PsiMethod -> psi
         is KtClassOrObject -> {
             // For synthetic members in enum classes, `psi` points to their containing enum class.
@@ -141,7 +150,7 @@ context(KtAnalysisSession)
 private fun toPsiMethodForDeserialized(
     functionSymbol: KtFunctionLikeSymbol,
     context: KtElement,
-    psi: KtFunction,
+    psi: KtFunction?,
 ): PsiMethod? {

     fun equalSignatures(psiMethod: PsiMethod): Boolean {
@@ -179,16 +188,44 @@ private fun toPsiMethodForDeserialized(
         return psiMethodReturnType == symbolReturnType
     }

-    // NB: no fake generation for member functions, as deserialized source PSI for built-ins can trigger FIR build/resolution
-    fun PsiClass.lookup(fake: Boolean): PsiMethod? {
+    fun PsiClass.lookup(): PsiMethod? {
         val candidates =
             if (functionSymbol is KtConstructorSymbol)
                 constructors.filter { it.parameterList.parameters.size == functionSymbol.valueParameters.size }
-            else
-                methods.filter { it.name == psi.name }
+            else {
+                val jvmName = when (functionSymbol) {
+                    is KtPropertyGetterSymbol -> {
+                        functionSymbol.getJvmNameFromAnnotation(PROPERTY_GETTER.toOptionalFilter())
+                    }
+                    is KtPropertySetterSymbol -> {
+                        functionSymbol.getJvmNameFromAnnotation(PROPERTY_SETTER.toOptionalFilter())
+                    }
+                    else -> {
+                        functionSymbol.getJvmNameFromAnnotation()
+                    }
+                }
+                val id = jvmName
+                    ?: functionSymbol.callableIdIfNonLocal?.callableName?.identifierOrNullIfSpecial
+                    ?: psi?.name
+                methods.filter { it.name == id }
+            }
+
         return when (candidates.size) {
-            0 -> if (fake) UastFakeDeserializedSourceLightMethod(psi, this) else null
-            1 -> candidates.single()
+            0 -> {
+                if (psi != null) {
+                    UastFakeDeserializedSourceLightMethod(psi, this@lookup)
+                } else if (functionSymbol is KtFunctionSymbol) {
+                    UastFakeDeserializedSymbolLightMethod(
+                        functionSymbol.createPointer(),
+                        functionSymbol.name.identifier,
+                        this@lookup,
+                        context
+                    )
+                } else null
+            }
+            1 -> {
+                candidates.single()
+            }
             else -> {
                 candidates.firstOrNull { equalSignatures(it) } ?: candidates.first()
             }
@@ -196,17 +233,46 @@ private fun toPsiMethodForDeserialized(
     }

     // Deserialized member function
-    return psi.containingClass()?.getClassId()?.let { classId ->
+    val classId = psi?.containingClass()?.getClassId()
+        ?: functionSymbol.callableIdIfNonLocal?.classId
+    if (classId != null) {
         toPsiClass(
             buildClassType(classId),
             source = null,
             context,
             TypeOwnerKind.DECLARATION,
-            isBoxed = false
-        )?.lookup(fake = false)
-    } ?:
+        )?.lookup()?.let { return it }
+    }
     // Deserialized top-level function
-    psi.containingKtFile.findFacadeClass()?.lookup(fake = true)
+    return if (psi != null) {
+        // Lint/UAST IDE: with deserialized PSI
+        psi.containingKtFile.findFacadeClass()?.lookup()
+    } else if (functionSymbol is KtFunctionSymbol) {
+        // Lint/UAST CLI: attempt to find the binary class
+        //   with the facade fq name from the resolved symbol
+        functionSymbol.getContainingJvmClassName()?.let { fqName ->
+            JavaPsiFacade.getInstance(context.project)
+                .findClass(fqName, context.resolveScope)
+                ?.lookup()
+        }
+    } else null
+}
+
+private fun KtAnnotatedSymbol.getJvmNameFromAnnotation(
+    useSiteTargetFilter: AnnotationUseSiteTargetFilter = AnyAnnotationUseSiteTargetFilter,
+): String? {
+    val anno = annotationsByClassId(JvmStandardClassIds.JVM_NAME_CLASS_ID, useSiteTargetFilter).firstOrNull() ?: return null
+    return (anno.arguments.firstOrNull()?.expression as? KtConstantAnnotationValue)?.constantValue?.value as? String
+}
+
+private fun AnnotationUseSiteTarget.toOptionalFilter(): AnnotationUseSiteTargetFilter {
+    return annotationUseSiteTargetFilterOf(NoAnnotationUseSiteTargetFilter, toFilter())
+}
+
+private fun annotationUseSiteTargetFilterOf(
+    vararg filters: AnnotationUseSiteTargetFilter,
+): AnnotationUseSiteTargetFilter = AnnotationUseSiteTargetFilter { useSiteTarget ->
+    filters.any { filter -> filter.isAllowed(useSiteTarget) }
 }

 context(KtAnalysisSession)
@@ -333,12 +399,24 @@ internal tailrec fun psiForUast(symbol: KtSymbol, project: Project): PsiElement?
     return symbol.psi
 }

-internal fun KtElement.toPsiElementAsLightElement(): PsiElement? {
-    val candidates = toLightElements().takeIf { it.isNotEmpty() } ?: return null
+internal fun KtElement.toPsiElementAsLightElement(
+    sourcePsi: KtExpression? = null
+): PsiElement? {
     if (this is KtProperty) {
-        // Weigh [PsiField]
-        return candidates.firstOrNull { psiMember -> psiMember is PsiField }
-            ?: candidates.firstOrNull()
+        with(getAccessorLightMethods()) {
+            // Weigh [PsiField]
+            backingField?.let { return it }
+            val readWriteAccess = sourcePsi?.readWriteAccess()
+            when {
+                readWriteAccess?.isWrite == true -> {
+                    setter?.let { return it }
+                }
+                readWriteAccess?.isRead == true -> {
+                    getter?.let { return it }
+                }
+                else -> {}
+            }
+        }
     }
-    return candidates.firstOrNull()
+    return toLightElements().firstOrNull()
 }
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
index 676be03bcac3..e6e502ee3251 100644
--- a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
@@ -430,7 +430,7 @@ interface FirKotlinUastResolveProviderService : BaseKotlinUastResolveProviderSer
 
                     is KtLibraryModule -> {
                         // For decompiled declarations, we can try light element conversion (only).
-                        (resolvedTargetElement as? KtElement)?.toPsiElementAsLightElement()?.let { return it }
+                        (resolvedTargetElement as? KtElement)?.toPsiElementAsLightElement(ktExpression)?.let { return it }
                     }
 
                     else -> {}
