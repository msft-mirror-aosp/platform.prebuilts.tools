diff --git a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt
index 914c096ceab0..6b84229ad10f 100644
--- a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt
+++ b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt
@@ -40,6 +40,7 @@ import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.resolve.jvm.KotlinCliJavaFileManager
 import org.jetbrains.kotlin.util.PerformanceCounter
 import org.jetbrains.kotlin.utils.addIfNotNull
+import org.jetbrains.kotlin.utils.getOrPutNullable
 import java.util.*
 
 // TODO: do not inherit from CoreJavaFileManager to avoid accidental usage of its methods which do not use caches/indices
@@ -73,7 +74,8 @@ class KotlinCliJavaFileManagerImpl(private val myPsiManager: PsiManager) : CoreJ
     private fun findVirtualFileForTopLevelClass(classId: ClassId, searchScope: GlobalSearchScope): VirtualFile? {
         val relativeClassName = classId.relativeClassName.asString()
         val outerMostClassFqName = classId.packageFqName.child(classId.relativeClassName.pathSegments().first())
-        return topLevelClassesCache.getOrPut(outerMostClassFqName) {
+        // KT-35614: getOrPut -> getOrPutNullable
+        return topLevelClassesCache.getOrPutNullable(outerMostClassFqName) {
             // Search java sources first. For build tools, it makes sense to build new files passing all the
             // class files for the previous build on the class path.
             //
diff --git a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt
index 99b5300d44f..8ce4360c082 100644
--- a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt
+++ b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt
@@ -384,7 +384,9 @@ class KotlinCoreEnvironment private constructor(
             is JvmModulePathRoot ->
                 if (root.file.isFile) findJarRoot(root.file) else findExistingRoot(root, "Java module root")
             is JavaSourceRoot ->
-                findExistingRoot(root, "Java source root")
+                // Partial cherry pick of https://github.com/JetBrains/kotlin/pull/3649 supporting .srcjar roots.
+                if (root.file.isFile && root.file.path.endsWith(".srcjar")) findJarRoot(root.file)
+                else findExistingRoot(root, "Java source root")
             is VirtualJvmClasspathRoot -> root.file
             else ->
                 throw IllegalStateException("Unexpected root: $root")
@@ -606,11 +608,15 @@ class KotlinCoreEnvironment private constructor(
                                 "(cp:\n  ${(Thread.currentThread().contextClassLoader as? UrlClassLoader)?.urls?.joinToString("\n  ") { it.file }})"
                     )
 
+            try {
             CoreApplicationEnvironment.registerExtensionPointAndExtensions(
                 FileSystems.getDefault().getPath(pluginRoot.path),
                 configFilePath,
                 ApplicationManager.getApplication().extensionArea
             )
+            } catch (e: RuntimeException) {
+              // IDEA-311845: ExpiredPluginsState reads bin/idea.properties
+            }
         }
 
         @JvmStatic

