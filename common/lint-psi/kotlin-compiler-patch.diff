diff --git a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt
index 0cceaca7f05..590a55e106b 100644
--- a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt
+++ b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCliJavaFileManagerImpl.kt
@@ -40,6 +40,7 @@ import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.resolve.jvm.KotlinCliJavaFileManager
 import org.jetbrains.kotlin.util.PerformanceCounter
 import org.jetbrains.kotlin.utils.addIfNotNull
+import org.jetbrains.kotlin.utils.getOrPutNullable
 import java.util.*
 
 // TODO: do not inherit from CoreJavaFileManager to avoid accidental usage of its methods which do not use caches/indices
@@ -72,7 +73,7 @@ class KotlinCliJavaFileManagerImpl(private val myPsiManager: PsiManager) : CoreJ
 
     private fun findVirtualFileForTopLevelClass(classId: ClassId, searchScope: GlobalSearchScope): VirtualFile? {
         val relativeClassName = classId.relativeClassName.asString()
-        return topLevelClassesCache.getOrPut(classId.packageFqName.child(classId.relativeClassName.pathSegments().first())) {
+        return topLevelClassesCache.getOrPutNullable(classId.packageFqName.child(classId.relativeClassName.pathSegments().first())) {  // KT-35614: getOrPut -> getOrPutNullable
             index.findClass(classId) { dir, type ->
                 findVirtualFileGivenPackage(dir, relativeClassName, type)
             } ?: singleJavaFileRootsIndex.findJavaSourceClass(classId)
diff --git a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt
index 158a462c2e1..6578f0c649c 100644
--- a/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt
+++ b/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/compiler/KotlinCoreEnvironment.kt
@@ -502,7 +502,8 @@ class KotlinCoreEnvironment private constructor(
             }
         }
 
-        private fun createApplicationEnvironment(
+        // made public for Android Lint
+        fun createApplicationEnvironment(
             parentDisposable: Disposable, configuration: CompilerConfiguration, unitTestMode: Boolean
         ): KotlinCoreApplicationEnvironment {
             val applicationEnvironment = KotlinCoreApplicationEnvironment.create(parentDisposable, unitTestMode)
@@ -595,7 +596,8 @@ class KotlinCoreEnvironment private constructor(
             CandidateInterceptor.registerExtensionPoint(project)
         }
 
-        internal fun registerExtensionsFromPlugins(project: MockProject, configuration: CompilerConfiguration) {
+        // made public for Android Lint
+        fun registerExtensionsFromPlugins(project: MockProject, configuration: CompilerConfiguration) {
             val messageCollector = configuration.get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY)
             for (registrar in configuration.getList(ComponentRegistrar.PLUGIN_COMPONENT_REGISTRARS)) {
                 try {
@@ -661,7 +663,8 @@ class KotlinCoreEnvironment private constructor(
             }
         }
 
-        private fun registerProjectServicesForCLI(@Suppress("UNUSED_PARAMETER") projectEnvironment: JavaCoreProjectEnvironment) {
+        // made public for Android Lint
+        fun registerProjectServicesForCLI(@Suppress("UNUSED_PARAMETER") projectEnvironment: JavaCoreProjectEnvironment) {
             /**
              * Note that Kapt may restart code analysis process, and CLI services should be aware of that.
              * Use PsiManager.getModificationTracker() to ensure that all the data you cached is still valid.
diff --git a/compiler/light-classes/src/org/jetbrains/kotlin/asJava/classes/KtLightClassForSourceDeclaration.kt b/compiler/light-classes/src/org/jetbrains/kotlin/asJava/classes/KtLightClassForSourceDeclaration.kt
index ef8364eca42..38215be5392 100644
--- a/compiler/light-classes/src/org/jetbrains/kotlin/asJava/classes/KtLightClassForSourceDeclaration.kt
+++ b/compiler/light-classes/src/org/jetbrains/kotlin/asJava/classes/KtLightClassForSourceDeclaration.kt
@@ -275,7 +275,11 @@ abstract class KtLightClassForSourceDeclaration(
         }
 
         val thisDescriptor = getDescriptor()
-        return qualifiedName != null && thisDescriptor != null && checkSuperTypeByFQName(thisDescriptor, qualifiedName, checkDeep)
+        return if (qualifiedName == null || thisDescriptor == null) {
+            super.isInheritor(baseClass, checkDeep)
+        } else {
+            checkSuperTypeByFQName(thisDescriptor, qualifiedName, checkDeep)
+        }
     }
 
     @Throws(IncorrectOperationException::class)
diff --git a/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinAbstractUElement.kt b/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinAbstractUElement.kt
index 5f03a513dc4..1ccf4de2081 100644
--- a/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinAbstractUElement.kt
+++ b/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinAbstractUElement.kt
@@ -145,7 +145,22 @@ abstract class KotlinAbstractUElement(private val givenParent: UElement?) : Kotl
             return false
         }
 
-        return this.psi == other.psi
+        if (this.psi == other.psi) {
+            if (this.psi == null) {
+                // Two UElements can be different but both have null PSI fields; in that case,
+                // do a deeper check
+                if (this === other) { // same instance: always equal
+                    return true
+                }
+                if (this.javaClass !== other.javaClass) { // different types: never equal
+                    return false
+                }
+                return this.asSourceString() == other.asSourceString() // source code equality
+            }
+            return true
+        } else {
+            return false
+        }
     }
 
     override fun hashCode() = psi?.hashCode() ?: 0
diff --git a/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinUastLanguagePlugin.kt b/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinUastLanguagePlugin.kt
index 96f3dba346c..47099469df8 100644
--- a/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinUastLanguagePlugin.kt
+++ b/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/KotlinUastLanguagePlugin.kt
@@ -406,6 +406,14 @@ internal object KotlinConverter {
             else {
                 expr<UDeclarationsExpression>(build(::createLocalFunctionDeclaration))
             }
+            is KtAnnotatedExpression -> {
+                val base = expression.baseExpression
+                if (base != null) {
+                    convertExpression(base, givenParent, requiredType)
+                } else {
+                    expr<UExpression>(build(::UnknownKotlinExpression))
+                }
+            }
 
             else -> expr<UExpression>(build(::UnknownKotlinExpression))
         }}
diff --git a/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/expressions/ElvisExpression.kt b/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/expressions/ElvisExpression.kt
index 9e2f4bf193c..62b07e16f25 100644
--- a/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/expressions/ElvisExpression.kt
+++ b/plugins/uast-kotlin/src/org/jetbrains/uast/kotlin/expressions/ElvisExpression.kt
@@ -3,6 +3,7 @@ package org.jetbrains.uast.kotlin.expressions
 import com.intellij.psi.PsiElement
 import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiType
+import org.jetbrains.kotlin.psi.KtAnnotatedExpression
 import org.jetbrains.kotlin.psi.KtBinaryExpression
 import org.jetbrains.kotlin.psi.KtExpression
 import org.jetbrains.kotlin.resolve.BindingContext
@@ -95,7 +96,11 @@ class KotlinUElvisExpression(
     override val sourcePsi: PsiElement? = elvisExpression
     override val psi: PsiElement? = sourcePsi
     override val kind = KotlinSpecialExpressionKinds.ELVIS
-    override val annotations: List<UAnnotation> = emptyList()
+    override val annotations: List<UAnnotation>
+        get() {
+            val annotatedExpression = sourcePsi?.parent as? KtAnnotatedExpression ?: return emptyList()
+            return annotatedExpression.annotationEntries.map { KotlinUAnnotation(it, this) }
+        }
     override val expressions: List<UExpression> by lz {
         createElvisExpressions(left, right, this, elvisExpression.parent)
     }
