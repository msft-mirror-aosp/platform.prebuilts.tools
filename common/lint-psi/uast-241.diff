diff --git a/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt b/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt
index 8d3197671645..73fbfea28e6c 100644
--- a/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt
+++ b/plugins/kotlin/uast/uast-kotlin/src/org/jetbrains/uast/kotlin/internal/kotlinInternalUastUtils.kt
@@ -561,7 +561,17 @@ private fun resolveDeserialized(
         }
         is ProtoBuf.Property -> {
             JvmProtoBufUtil.getJvmFieldSignature(proto, nameResolver, typeTable, false)
-                ?.let { signature -> psiClass.fields.firstOrNull { it.name == signature.name } }
+                ?.let { signature ->
+                    // property in companion object is actually materialized at the containing class.
+                    val containingClassIsCompanionObject =
+                        (descriptor.containingDeclaration as? DeserializedClassDescriptor)?.isCompanionObject == true
+                    val psiClassToLookup = if (containingClassIsCompanionObject) {
+                        psiClass.containingClass ?: psiClass
+                    } else {
+                        psiClass
+                    }
+                    psiClassToLookup.fields.firstOrNull { it.name == signature.name }
+                }
                 ?.let { return it }
 
             val propertySignature = proto.getExtensionOrNull(JvmProtoBuf.propertySignature)
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt
index 42b83e5050a08..03c542da6d502 100644
--- a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/internal/firKotlinInternalUastUtils.kt
@@ -14,10 +14,8 @@ import org.jetbrains.kotlin.analysis.api.symbols.*
 import org.jetbrains.kotlin.analysis.api.types.*
 import org.jetbrains.kotlin.analysis.project.structure.KtSourceModule
 import org.jetbrains.kotlin.analysis.providers.DecompiledPsiDeclarationProvider.findPsi
+import org.jetbrains.kotlin.asJava.*
 import org.jetbrains.kotlin.asJava.classes.lazyPub
-import org.jetbrains.kotlin.asJava.findFacadeClass
-import org.jetbrains.kotlin.asJava.getRepresentativeLightMethod
-import org.jetbrains.kotlin.asJava.toLightClass
 import org.jetbrains.kotlin.idea.KotlinLanguage
 import org.jetbrains.kotlin.name.StandardClassIds
 import org.jetbrains.kotlin.psi.*
@@ -25,7 +23,8 @@ import org.jetbrains.kotlin.psi.psiUtil.containingClass
 import org.jetbrains.kotlin.type.MapPsiToAsmDesc
 import org.jetbrains.uast.*
 import org.jetbrains.uast.kotlin.*
-import org.jetbrains.uast.kotlin.psi.UastFakeDeserializedLightMethod
+import org.jetbrains.uast.kotlin.psi.UastFakeDeserializedSourceLightMethod
+import org.jetbrains.uast.kotlin.psi.UastFakeDeserializedSymbolLightMethod
 import org.jetbrains.uast.kotlin.psi.UastFakeSourceLightMethod
 import org.jetbrains.uast.kotlin.psi.UastFakeSourceLightPrimaryConstructor
 
@@ -80,6 +79,24 @@ internal fun toPsiMethod(
     functionSymbol: KtFunctionLikeSymbol,
     context: KtElement,
 ): PsiMethod? {
+    // `inline` from binary dependency, which we can't find source PSI, so fake it
+    if (functionSymbol.origin == KtSymbolOrigin.LIBRARY &&
+        (functionSymbol as? KtFunctionSymbol)?.isInline == true &&
+        functionSymbol.typeParameters.any { it.isReified }
+    ) {
+        functionSymbol.getContainingJvmClassName()?.let { fqName ->
+            JavaPsiFacade.getInstance(context.project)
+                .findClass(fqName, context.resolveScope)
+                ?.let { containingClass ->
+                    return UastFakeDeserializedSymbolLightMethod(
+                        functionSymbol.createPointer(),
+                        functionSymbol.name.identifier,
+                        containingClass,
+                        context
+                    )
+                }
+        }
+    }
     return when (val psi = psiForUast(functionSymbol, context.project)) {
         null -> null
         is PsiMethod -> psi
@@ -135,7 +152,7 @@ private fun toPsiMethodForDeserialized(
             else
                 methods.filter { it.name == psi.name }
         return when (candidates.size) {
-            0 -> if (fake) UastFakeDeserializedLightMethod(psi, this) else null
+            0 -> if (fake) UastFakeDeserializedSourceLightMethod(psi, this) else null
             1 -> candidates.single()
             else -> {
                 candidates.firstOrNull { it.desc == desc(functionSymbol, it, context) } ?: candidates.first()
@@ -290,7 +307,10 @@ internal fun getKtType(ktCallableDeclaration: KtCallableDeclaration): KtType? {
 context(KtAnalysisSession)
 internal tailrec fun psiForUast(symbol: KtSymbol, project: Project): PsiElement? {
     if (symbol.origin == KtSymbolOrigin.LIBRARY) {
-        return findPsi(symbol, project) ?: symbol.psi
+        // UAST/Lint CLI: use [DecompiledPsiDeclarationProvider] / [KotlinStaticPsiDeclarationFromBinaryModuleProvider]
+        return findPsi(symbol, project)
+            // UAST/Lint IDE: decompiled PSI
+            ?: symbol.psi // will be simplified as per KTIJ-28497
     }
 
     if (symbol is KtCallableSymbol) {
@@ -304,3 +324,13 @@ internal tailrec fun psiForUast(symbol: KtSymbol, project: Project): PsiElement?
 
     return symbol.psi
 }
+
+internal fun KtElement.toPsiElementAsLightElement(): PsiElement? {
+    val candidates = toLightElements().takeIf { it.isNotEmpty() } ?: return null
+    if (this is KtProperty) {
+        // Weigh [PsiField]
+        return candidates.firstOrNull { psiMember -> psiMember is PsiField }
+            ?: candidates.firstOrNull()
+    }
+    return candidates.firstOrNull()
+}
diff --git a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeLightMethodBase.kt b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeLightMethodBase.kt
index d214d8726070..8c384269df4d 100644
--- a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeLightMethodBase.kt
+++ b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeLightMethodBase.kt
@@ -79,4 +79,6 @@ abstract class UastFakeLightMethodBase(
     }
 
     override fun getParent(): PsiElement? = containingClass
+
+    override fun toString(): String = "${this::class.simpleName} of $name"
 }
\ No newline at end of file
diff --git a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethod.kt b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethod.kt
index 0a5fed5b80d8..7882c653cd48 100644
--- a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethod.kt
+++ b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethod.kt
@@ -1,19 +1,14 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 
 package org.jetbrains.uast.kotlin.psi
 
 import com.intellij.psi.*
-import com.intellij.psi.impl.light.LightModifierList
 import com.intellij.psi.impl.light.LightParameterListBuilder
 import com.intellij.psi.impl.light.LightReferenceListBuilder
 import org.jetbrains.annotations.ApiStatus
-import org.jetbrains.kotlin.analysis.api.types.KtTypeNullability
 import org.jetbrains.kotlin.asJava.elements.KotlinLightTypeParameterBuilder
 import org.jetbrains.kotlin.asJava.elements.KotlinLightTypeParameterListBuilder
-import org.jetbrains.kotlin.asJava.elements.KtLightAnnotationForSourceEntry
-import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.*
-import org.jetbrains.kotlin.utils.SmartList
 import org.jetbrains.uast.UastErrorType
 import org.jetbrains.uast.UastLazyPart
 import org.jetbrains.uast.getOrBuild
diff --git a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethodBase.kt b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethodBase.kt
index f069600bb1a9..66de9c548f87 100644
--- a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethodBase.kt
+++ b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/psi/UastFakeSourceLightMethodBase.kt
@@ -123,4 +123,6 @@ abstract class UastFakeSourceLightMethodBase<T : KtDeclaration>(
     }
 
     override fun hashCode(): Int = original.hashCode()
+
+    override fun toString(): String = "${this::class.simpleName} of ${original.name}"
 }
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedLightMethod.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedSourceLightMethod.kt
similarity index 58%
rename from plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedLightMethod.kt
rename to plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedSourceLightMethod.kt
index aefc3efa5458..aa455ba316b7 100644
--- a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedLightMethod.kt
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedSourceLightMethod.kt
@@ -1,7 +1,4 @@
-/*
- * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
- * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
- */
+// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.uast.kotlin.psi
 
 import com.intellij.psi.PsiClass
@@ -14,9 +11,7 @@ import org.jetbrains.kotlin.psi.KtFunction
  * that are in source, but not converted/supported by light classes (e.g., due to the presence of @JvmSynthetic).
  * To keep the semantics of [UastFakeSourceLightMethod], here we introduce a dummy abstraction as a placeholder.
  */
-internal class UastFakeDeserializedLightMethod(
-    private val original: KtFunction,
+internal class UastFakeDeserializedSourceLightMethod(
+    original: KtFunction,
     containingClass: PsiClass,
-) : UastFakeSourceLightMethod(original, containingClass) {
-    override fun toString(): String = "${this::class.simpleName} of ${original.name}"
-}
+) : UastFakeSourceLightMethod(original, containingClass)
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedSymbolLightMethod.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedSymbolLightMethod.kt
new file mode 100644
index 000000000000..902bdd6e0e02
--- /dev/null
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/psi/UastFakeDeserializedSymbolLightMethod.kt
@@ -0,0 +1,119 @@
+// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+package org.jetbrains.uast.kotlin.psi
+
+import com.intellij.psi.*
+import com.intellij.psi.impl.light.LightModifierList
+import com.intellij.psi.impl.light.LightParameterListBuilder
+import org.jetbrains.kotlin.analysis.api.annotations.annotations
+import org.jetbrains.kotlin.analysis.api.symbols.KtFunctionSymbol
+import org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer
+import org.jetbrains.kotlin.analysis.api.symbols.receiverType
+import org.jetbrains.kotlin.analysis.api.types.KtTypeNullability
+import org.jetbrains.kotlin.asJava.toLightAnnotation
+import org.jetbrains.kotlin.psi.KtElement
+import org.jetbrains.kotlin.psi.KtTypeReference
+import org.jetbrains.kotlin.utils.SmartList
+import org.jetbrains.uast.UastErrorType
+import org.jetbrains.uast.UastLazyPart
+import org.jetbrains.uast.getOrBuild
+import org.jetbrains.uast.kotlin.internal.analyzeForUast
+
+/**
+ * A fake light method from binary, which is not materialized for some reason (e.g., `inline`)
+ *
+ * Due to its origin, BINARY, we don't have source PSI, but at least we have a pointer to
+ * Analysis API symbol if it's resolved.
+ */
+internal class UastFakeDeserializedSymbolLightMethod(
+    private val original: KtSymbolPointer<KtFunctionSymbol>,
+    name: String,
+    containingClass: PsiClass,
+    private val context: KtElement,
+) : UastFakeLightMethodBase(
+    context.manager,
+    context.language,
+    name,
+    LightParameterListBuilder(context.manager, context.language),
+    LightModifierList(context.manager),
+    containingClass
+) {
+    private val _isSuspend = UastLazyPart<Boolean>()
+
+    override fun isSuspendFunction(): Boolean =
+        _isSuspend.getOrBuild {
+            analyzeForUast(context) {
+                val functionSymbol = original.restoreSymbol() ?: return@analyzeForUast false
+                functionSymbol.isSuspend
+            }
+        }
+
+    private val _isUnit = UastLazyPart<Boolean>()
+
+    override fun isUnitFunction(): Boolean =
+        _isUnit.getOrBuild {
+            analyzeForUast(context) {
+                val functionSymbol = original.restoreSymbol() ?: return@analyzeForUast false
+                functionSymbol.returnType.isUnit
+            }
+        }
+
+    override fun computeNullability(): KtTypeNullability? {
+        return analyzeForUast(context) {
+            val functionSymbol = original.restoreSymbol() ?: return@analyzeForUast null
+            functionSymbol.returnType.nullability
+        }
+    }
+
+    override fun computeAnnotations(annotations: SmartList<PsiAnnotation>) {
+        analyzeForUast(context) {
+            val functionSymbol = original.restoreSymbol() ?: return
+            functionSymbol.annotations.forEach { annoApp ->
+                annoApp.psi?.toLightAnnotation()?.let { annotations.add(it) }
+            }
+        }
+    }
+
+    private val parameterListPart = UastLazyPart<PsiParameterList>()
+
+    override fun getParameterList(): PsiParameterList =
+        parameterListPart.getOrBuild {
+            object : LightParameterListBuilder(context.manager, context.language) {
+                override fun getParent(): PsiElement = this@UastFakeDeserializedSymbolLightMethod
+                override fun getContainingFile(): PsiFile = parent.containingFile
+
+                init {
+                    val parameterList = this
+                    val context = this@UastFakeDeserializedSymbolLightMethod.context
+
+                    analyzeForUast(context) l@{
+                        val functionSymbol = original.restoreSymbol() ?: return@l
+                        (functionSymbol.receiverParameter?.psi as? KtTypeReference)?.let { receiver ->
+                            parameterList.addParameter(
+                                UastKotlinPsiParameterBase(
+                                    "\$this\$$name",
+                                    functionSymbol.receiverType?.asPsiType(context, allowErrorTypes = true) ?: UastErrorType,
+                                    parameterList,
+                                    receiver
+                                )
+                            )
+                        }
+
+                        for (p in functionSymbol.valueParameters) {
+                            val type = p.returnType.asPsiType(context, allowErrorTypes = true) ?: UastErrorType
+                            val adjustedType = if (p.isVararg && type is PsiArrayType)
+                                PsiEllipsisType(type.componentType, type.annotationProvider)
+                            else type
+                            parameterList.addParameter(
+                                UastKotlinPsiParameterBase(
+                                    p.name.identifier,
+                                    adjustedType,
+                                    parameterList,
+                                    (p.psi as? KtElement) ?: context
+                                )
+                            )
+                        }
+                    }
+                }
+            }
+        }
+}
