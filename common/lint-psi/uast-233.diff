diff --git a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/declarations/AbstractKotlinUVariable.kt b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/declarations/AbstractKotlinUVariable.kt
index 55dc5d1daa61d..87ecfd28ea64c 100644
--- a/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/declarations/AbstractKotlinUVariable.kt
+++ b/plugins/kotlin/uast/uast-kotlin-base/src/org/jetbrains/uast/kotlin/declarations/AbstractKotlinUVariable.kt
@@ -75,7 +75,9 @@ abstract class AbstractKotlinUVariable(
                 is KtNamedDeclaration -> sourcePsi.nameIdentifier
                 is KtTypeReference -> sourcePsi.typeElement?.let {
                     // receiver param in extension function
-                    (it as? KtUserType)?.referenceExpression?.getIdentifier() ?: it
+                    // Unwrap the type if the receiver param is nullable
+                    val typeElement = (it as? KtNullableType)?.innerType ?: it
+                    (typeElement as? KtUserType)?.referenceExpression?.getIdentifier() ?: it
                 } ?: sourcePsi
                 is KtNameReferenceExpression -> sourcePsi.getReferencedNameElement()
                 is KtBinaryExpression, is KtCallExpression -> null // e.g. `foo("Lorem ipsum") ?: foo("dolor sit amet")`
diff --git a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
index 669638dd7b10e..aa94796248e02 100644
--- a/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
+++ b/plugins/kotlin/uast/uast-kotlin-fir/src/org/jetbrains/uast/kotlin/FirKotlinUastResolveProviderService.kt
@@ -388,12 +388,15 @@ interface FirKotlinUastResolveProviderService : BaseKotlinUastResolveProviderSer
         fun resolveToPsiClassOrEnumEntry(classOrObject: KtClassOrObject): PsiElement? {
             analyzeForUast(ktExpression) {
                 val ktType = when (classOrObject) {
-                    is KtEnumEntry ->
-                        classOrObject.getEnumEntrySymbol().callableIdIfNonLocal?.classId?.let { enumClassId ->
-                            buildClassType(enumClassId)
-                        }
-                    else ->
-                        classOrObject.getClassOrObjectSymbol()?.let(::buildClassType)
+                    is KtEnumEntry -> {
+                        classOrObject.getEnumEntrySymbol().callableIdIfNonLocal?.classId?.let(::buildClassType)
+                    }
+                    else -> {
+                        // NB: Avoid symbol creation/retrieval
+                        classOrObject.getClassId()?.let(::buildClassType)
+                            // Fallback option for local class
+                            ?: classOrObject.getClassOrObjectSymbol()?.let(::buildClassType)
+                    }
                 } ?: return null
                 val psiClass = toPsiClass(ktType, source = null, classOrObject, classOrObject.typeOwnerKind)
                 return when (classOrObject) {
