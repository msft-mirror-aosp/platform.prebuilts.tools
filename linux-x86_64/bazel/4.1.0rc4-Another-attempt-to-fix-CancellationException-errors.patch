From 52ff93165e0983d52b810dd892a00ae681f182b3 Mon Sep 17 00:00:00 2001
From: tomrenn <tomrenn@google.com>
Date: Tue, 11 May 2021 17:44:43 +0000
Subject: [PATCH] Another attempt to fix CancellationException errors

See cl/370841840 snapshot #4
---
 .../build/lib/remote/util/AsyncTaskCache.java | 193 +++++++-----------
 1 file changed, 73 insertions(+), 120 deletions(-)

diff --git a/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java b/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java
index c3d2c25267..52688a33a7 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java
@@ -18,17 +18,15 @@ import static com.google.common.base.Preconditions.checkState;
 import com.google.common.collect.ImmutableSet;
 import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.Completable;
+import io.reactivex.rxjava3.core.Observable;
 import io.reactivex.rxjava3.core.Single;
 import io.reactivex.rxjava3.core.SingleObserver;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.subjects.AsyncSubject;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
-import java.util.concurrent.CancellationException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.concurrent.GuardedBy;
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -91,79 +89,51 @@ public final class AsyncTaskCache<KeyT, ValueT> {
     return execute(key, task, false);
   }
 
-  private static class Execution<ValueT> {
-    private final AtomicBoolean isTaskDisposed = new AtomicBoolean(false);
-    private final Single<ValueT> task;
-    private final AsyncSubject<ValueT> asyncSubject = AsyncSubject.create();
-    private final AtomicInteger referenceCount = new AtomicInteger(0);
-    private final AtomicReference<Disposable> taskDisposable = new AtomicReference<>(null);
-
-    Execution(Single<ValueT> task) {
-      this.task = task;
+  /** Returns count of subscribers for a task. */
+  public int getSubscriberCount(KeyT key) {
+    synchronized (lock) {
+      Execution<ValueT> task = inProgress.get(key);
+      if (task != null) {
+        return task.getSubscriberCount();
+      }
     }
 
-    Single<ValueT> executeIfNot() {
-      checkState(!isTaskDisposed(), "disposed");
-
-      int subscribed = referenceCount.getAndIncrement();
-      if (taskDisposable.get() == null && subscribed == 0) {
-        task.subscribe(
-            new SingleObserver<ValueT>() {
-              @Override
-              public void onSubscribe(@NonNull Disposable d) {
-                taskDisposable.compareAndSet(null, d);
-              }
-
-              @Override
-              public void onSuccess(@NonNull ValueT value) {
-                asyncSubject.onNext(value);
-                asyncSubject.onComplete();
-              }
-
-              @Override
-              public void onError(@NonNull Throwable e) {
-                asyncSubject.onError(e);
-              }
-            });
-      }
+    return 0;
+  }
 
-      return Single.fromObservable(asyncSubject);
-    }
+  static class Execution<T> extends Single<T> {
+    private final Single<T> upstream;
+    private final AtomicInteger observerCount = new AtomicInteger(0);
+    private final AtomicBoolean disposed = new AtomicBoolean(false);
 
-    boolean isTaskTerminated() {
-      return asyncSubject.hasComplete() || asyncSubject.hasThrowable();
+    static <T> Execution<T> create(Single<T> upstream) {
+      return new Execution<>(upstream);
     }
 
-    boolean isTaskDisposed() {
-      return isTaskDisposed.get();
+    Execution(Single<T> upstream) {
+      Observable<T> observable =
+          Single.defer(
+                  () -> {
+                    checkState(!disposed.get(), "disposed");
+                    return upstream.doOnDispose(() -> disposed.set(true));
+                  })
+              .toObservable()
+              .publish()
+              .refCount();
+
+      this.upstream =
+          Single.fromObservable(observable)
+              .doOnLifecycle(d -> observerCount.incrementAndGet(), observerCount::decrementAndGet);
     }
 
-    void tryDisposeTask() {
-      checkState(!isTaskDisposed(), "disposed");
-      checkState(!isTaskTerminated(), "terminated");
-
-      if (referenceCount.decrementAndGet() == 0) {
-        isTaskDisposed.set(true);
-        asyncSubject.onError(new CancellationException("disposed"));
-
-        Disposable d = taskDisposable.get();
-        if (d != null) {
-          d.dispose();
-        }
-      }
+    int getSubscriberCount() {
+      return observerCount.get();
     }
-  }
 
-  /** Returns count of subscribers for a task. */
-  public int getSubscriberCount(KeyT key) {
-    synchronized (lock) {
-      Execution<ValueT> execution = inProgress.get(key);
-      if (execution != null) {
-        return execution.referenceCount.get();
-      }
+    @Override
+    protected void subscribeActual(@NonNull SingleObserver<? super T> observer) {
+      upstream.subscribe(observer);
     }
-
-    return 0;
   }
 
   /**
@@ -186,61 +156,44 @@ public final class AsyncTaskCache<KeyT, ValueT> {
             finished.remove(key);
 
             Execution<ValueT> execution =
-                inProgress.computeIfAbsent(
-                    key,
-                    ignoredKey -> {
-                      AtomicInteger subscribeTimes = new AtomicInteger(0);
-                      return new Execution<>(
-                          Single.defer(
-                              () -> {
-                                int times = subscribeTimes.incrementAndGet();
-                                checkState(times == 1, "Subscribed more than once to the task");
-                                return task;
-                              }));
-                    });
-
-            execution
-                .executeIfNot()
-                .subscribe(
-                    new SingleObserver<ValueT>() {
-                      @Override
-                      public void onSubscribe(@NonNull Disposable d) {
-                        emitter.setCancellable(
-                            () -> {
-                              d.dispose();
-
-                              if (!execution.isTaskTerminated()) {
-                                synchronized (lock) {
-                                  execution.tryDisposeTask();
-                                  if (execution.isTaskDisposed()) {
-                                    inProgress.remove(key);
-                                  }
-                                }
-                              }
-                            });
-                      }
-
-                      @Override
-                      public void onSuccess(@NonNull ValueT value) {
-                        synchronized (lock) {
-                          finished.put(key, value);
-                          inProgress.remove(key);
-                        }
-
-                        emitter.onSuccess(value);
-                      }
-
-                      @Override
-                      public void onError(@NonNull Throwable e) {
-                        synchronized (lock) {
-                          inProgress.remove(key);
-                        }
-
-                        if (!emitter.isDisposed()) {
-                          emitter.onError(e);
-                        }
-                      }
-                    });
+                inProgress.computeIfAbsent(key, ignoredKey -> Execution.create(task));
+
+            execution.subscribe(
+                new SingleObserver<ValueT>() {
+                  @Override
+                  public void onSubscribe(@NonNull Disposable d) {
+                    emitter.setCancellable(
+                        () -> {
+                          synchronized (lock) {
+                            d.dispose();
+                            if (execution.getSubscriberCount() == 0) {
+                              inProgress.remove(key);
+                            }
+                          }
+                        });
+                  }
+
+                  @Override
+                  public void onSuccess(@NonNull ValueT value) {
+                    synchronized (lock) {
+                      finished.put(key, value);
+                      inProgress.remove(key);
+                    }
+
+                    emitter.onSuccess(value);
+                  }
+
+                  @Override
+                  public void onError(@NonNull Throwable e) {
+                    synchronized (lock) {
+                      inProgress.remove(key);
+                    }
+
+                    if (!emitter.isDisposed()) {
+                      emitter.onError(e);
+                    }
+                  }
+                });
           }
         });
   }
-- 
2.20.1

