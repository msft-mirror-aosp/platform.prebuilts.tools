From f32b832a177ee0ae490df0f8a3537aba36e77441 Mon Sep 17 00:00:00 2001
From: tomrenn <tomrenn@google.com>
Date: Wed, 28 Apr 2021 17:04:37 +0000
Subject: [PATCH] Remote: Another attempt to fix the CancellationException
 error in AsyncTaskCache caused by a race condition. cl/370841840

GOOGLE:
RELNOTES: None.
---
 .../build/lib/remote/util/AsyncTask.java      | 340 ++++++++++++++++++
 .../build/lib/remote/util/AsyncTaskCache.java | 107 +-----
 2 files changed, 351 insertions(+), 96 deletions(-)
 create mode 100644 src/main/java/com/google/devtools/build/lib/remote/util/AsyncTask.java

diff --git a/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTask.java b/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTask.java
new file mode 100644
index 0000000000..b350c9a3d9
--- /dev/null
+++ b/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTask.java
@@ -0,0 +1,340 @@
+// Copyright 2021 The Bazel Authors. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package com.google.devtools.build.lib.remote.util;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import io.reactivex.rxjava3.annotations.CheckReturnValue;
+import io.reactivex.rxjava3.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.Nullable;
+import io.reactivex.rxjava3.core.Observable;
+import io.reactivex.rxjava3.core.Observer;
+import io.reactivex.rxjava3.disposables.Disposable;
+import io.reactivex.rxjava3.internal.observers.DeferredScalarDisposable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
+import io.reactivex.rxjava3.plugins.RxJavaPlugins;
+import io.reactivex.rxjava3.subjects.Subject;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A special {@link io.reactivex.rxjava3.subjects.AsyncSubject} that will automatically subscribe
+ * the upstream upon first subscription and dispose upstream if no observers. Upstream will only be
+ * subscribed once by this subject.
+ *
+ * <p>The implementation is based on AsyncSubject with some modifications. We should have extended
+ * it if it is not {@code final}.
+ */
+public final class AsyncTask<T> extends Subject<T> {
+
+  @SuppressWarnings("rawtypes")
+  static final AsyncDisposable[] EMPTY = new AsyncDisposable[0];
+
+  @SuppressWarnings("rawtypes")
+  static final AsyncDisposable[] TERMINATED = new AsyncDisposable[0];
+
+  static final int STATE_INIT = 0;
+  static final int STATE_PENDING = 1;
+  static final int STATE_SUBSCRIBED = 2;
+  static final int STATE_DISPOSED = 3;
+
+  @SuppressWarnings("unchecked")
+  final AtomicReference<AsyncDisposable<T>[]> subscribers = new AtomicReference<>(EMPTY);
+
+  final Observable<T> upstream;
+
+  final AtomicInteger upstreamState = new AtomicInteger(STATE_INIT);
+
+  Disposable upstreamDisposable = null;
+
+  /** Write before updating subscribers, read after reading subscribers as TERMINATED. */
+  Throwable error;
+
+  /** Write before updating subscribers, read after reading subscribers as TERMINATED. */
+  T value;
+
+  /**
+   * Creates a new AsyncTask.
+   *
+   * @param <T> the value type to be received and emitted
+   * @param upstream the task is subject will subscribe to.
+   * @return the new AsyncTask instance
+   */
+  @CheckReturnValue
+  @NonNull
+  public static <T> AsyncTask<T> create(Observable<T> upstream) {
+    return new AsyncTask<>(upstream);
+  }
+
+  AsyncTask(Observable<T> upstream) {
+    AtomicInteger subscribeTimes = new AtomicInteger(0);
+    this.upstream =
+        Observable.defer(
+            () -> {
+              int times = subscribeTimes.incrementAndGet();
+              checkState(times == 1, "Subscribed more than once to the upstream");
+              return upstream;
+            });
+  }
+
+  /** Returns whether the subject has disposed upstream. */
+  public boolean isDisposed() {
+    return upstreamState.get() == STATE_DISPOSED;
+  }
+
+  /** Returns the current subscriber count. */
+  public int getSubscriberCount() {
+    return subscribers.get().length;
+  }
+
+  @Override
+  public void onSubscribe(Disposable d) {
+    if (subscribers.get() == TERMINATED) {
+      d.dispose();
+    }
+
+    if (upstreamState.compareAndSet(STATE_PENDING, STATE_SUBSCRIBED)) {
+      upstreamDisposable = d;
+    }
+  }
+
+  @Override
+  public void onNext(T t) {
+    ExceptionHelper.nullCheck(t, "onNext called with a null value.");
+    if (subscribers.get() == TERMINATED) {
+      return;
+    }
+    value = t;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public void onError(Throwable t) {
+    ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
+    if (subscribers.get() == TERMINATED) {
+      RxJavaPlugins.onError(t);
+      return;
+    }
+    value = null;
+    error = t;
+    for (AsyncDisposable<T> as : subscribers.getAndSet(TERMINATED)) {
+      as.onError(t);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public void onComplete() {
+    if (subscribers.get() == TERMINATED) {
+      return;
+    }
+    T v = value;
+    AsyncDisposable<T>[] array = subscribers.getAndSet(TERMINATED);
+    if (v == null) {
+      for (AsyncDisposable<T> as : array) {
+        as.onComplete();
+      }
+    } else {
+      for (AsyncDisposable<T> as : array) {
+        as.complete(v);
+      }
+    }
+  }
+
+  @Override
+  @CheckReturnValue
+  public boolean hasObservers() {
+    return subscribers.get().length != 0;
+  }
+
+  @Override
+  @CheckReturnValue
+  public boolean hasThrowable() {
+    return subscribers.get() == TERMINATED && error != null;
+  }
+
+  @Override
+  @CheckReturnValue
+  public boolean hasComplete() {
+    return subscribers.get() == TERMINATED && error == null;
+  }
+
+  @Override
+  @CheckReturnValue
+  public Throwable getThrowable() {
+    return subscribers.get() == TERMINATED ? error : null;
+  }
+
+  @Override
+  protected void subscribeActual(Observer<? super T> observer) {
+    AsyncDisposable<T> as = new AsyncDisposable<>(observer, this);
+    observer.onSubscribe(as);
+    if (add(as)) {
+      if (as.isDisposed()) {
+        remove(as);
+      }
+    } else {
+      Throwable ex = error;
+      if (ex != null) {
+        observer.onError(ex);
+      } else {
+        T v = value;
+        if (v != null) {
+          as.complete(v);
+        } else {
+          as.onComplete();
+        }
+      }
+    }
+  }
+
+  /**
+   * Tries to add the given subscriber to the subscribers array atomically or returns false if the
+   * subject has terminated.
+   *
+   * <p>Subscribes upstream if hasn't done.
+   *
+   * @param ps the subscriber to add
+   * @return true if successful, false if the subject has terminated
+   */
+  boolean add(AsyncDisposable<T> ps) {
+    for (; ; ) {
+      AsyncDisposable<T>[] a = subscribers.get();
+      if (a == TERMINATED) {
+        return false;
+      }
+
+      int n = a.length;
+      @SuppressWarnings({"unchecked", "rawtypes"})
+      AsyncDisposable<T>[] b = new AsyncDisposable[n + 1];
+      System.arraycopy(a, 0, b, 0, n);
+      b[n] = ps;
+
+      if (subscribers.compareAndSet(a, b)) {
+        if (upstreamState.compareAndSet(STATE_INIT, STATE_PENDING)) {
+          upstream.subscribe(this);
+        }
+
+        return true;
+      }
+    }
+  }
+
+  /**
+   * Atomically removes the given subscriber if it is subscribed to the subject.
+   *
+   * <p>Disposes upstream if no more subscribers.
+   *
+   * @param ps the subject to remove
+   */
+  @SuppressWarnings({"unchecked", "rawtypes"})
+  void remove(AsyncDisposable<T> ps) {
+    for (; ; ) {
+      AsyncDisposable<T>[] a = subscribers.get();
+      int n = a.length;
+      if (n == 0) {
+        return;
+      }
+
+      int j = -1;
+      for (int i = 0; i < n; i++) {
+        if (a[i] == ps) {
+          j = i;
+          break;
+        }
+      }
+
+      if (j < 0) {
+        return;
+      }
+
+      AsyncDisposable<T>[] b;
+
+      if (n == 1) {
+        b = EMPTY;
+      } else {
+        b = new AsyncDisposable[n - 1];
+        System.arraycopy(a, 0, b, 0, j);
+        System.arraycopy(a, j + 1, b, j, n - j - 1);
+      }
+      if (subscribers.compareAndSet(a, b)) {
+        if (b == EMPTY) {
+          if (upstreamState.compareAndSet(STATE_SUBSCRIBED, STATE_DISPOSED)) {
+            upstreamDisposable.dispose();
+            onError(new CancellationException("disposed"));
+          }
+        }
+        return;
+      }
+    }
+  }
+
+  /**
+   * Returns true if the subject has any value.
+   *
+   * <p>The method is thread-safe.
+   *
+   * @return true if the subject has any value
+   */
+  @CheckReturnValue
+  public boolean hasValue() {
+    return subscribers.get() == TERMINATED && value != null;
+  }
+
+  /**
+   * Returns a single value the Subject currently has or null if no such value exists.
+   *
+   * <p>The method is thread-safe.
+   *
+   * @return a single value the Subject currently has or null if no such value exists
+   */
+  @Nullable
+  @CheckReturnValue
+  public T getValue() {
+    return subscribers.get() == TERMINATED ? value : null;
+  }
+
+  static final class AsyncDisposable<T> extends DeferredScalarDisposable<T> {
+    private static final long serialVersionUID = 5629876084736248016L;
+
+    final AsyncTask<T> parent;
+
+    AsyncDisposable(Observer<? super T> actual, AsyncTask<T> parent) {
+      super(actual);
+      this.parent = parent;
+    }
+
+    @Override
+    public void dispose() {
+      if (super.tryDispose()) {
+        parent.remove(this);
+      }
+    }
+
+    void onComplete() {
+      if (!isDisposed()) {
+        downstream.onComplete();
+      }
+    }
+
+    void onError(Throwable t) {
+      if (isDisposed()) {
+        RxJavaPlugins.onError(t);
+      } else {
+        downstream.onError(t);
+      }
+    }
+  }
+}
diff --git a/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java b/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java
index c3d2c25267..edecbce114 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/util/AsyncTaskCache.java
@@ -13,22 +13,15 @@
 // limitations under the License.
 package com.google.devtools.build.lib.remote.util;
 
-import static com.google.common.base.Preconditions.checkState;
-
 import com.google.common.collect.ImmutableSet;
 import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.Completable;
 import io.reactivex.rxjava3.core.Single;
 import io.reactivex.rxjava3.core.SingleObserver;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.subjects.AsyncSubject;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.concurrent.GuardedBy;
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -55,7 +48,7 @@ public final class AsyncTaskCache<KeyT, ValueT> {
   private final Map<KeyT, ValueT> finished;
 
   @GuardedBy("lock")
-  private final Map<KeyT, Execution<ValueT>> inProgress;
+  private final Map<KeyT, AsyncTask<ValueT>> inProgress;
 
   public static <KeyT, ValueT> AsyncTaskCache<KeyT, ValueT> create() {
     return new AsyncTaskCache<>();
@@ -91,75 +84,12 @@ public final class AsyncTaskCache<KeyT, ValueT> {
     return execute(key, task, false);
   }
 
-  private static class Execution<ValueT> {
-    private final AtomicBoolean isTaskDisposed = new AtomicBoolean(false);
-    private final Single<ValueT> task;
-    private final AsyncSubject<ValueT> asyncSubject = AsyncSubject.create();
-    private final AtomicInteger referenceCount = new AtomicInteger(0);
-    private final AtomicReference<Disposable> taskDisposable = new AtomicReference<>(null);
-
-    Execution(Single<ValueT> task) {
-      this.task = task;
-    }
-
-    Single<ValueT> executeIfNot() {
-      checkState(!isTaskDisposed(), "disposed");
-
-      int subscribed = referenceCount.getAndIncrement();
-      if (taskDisposable.get() == null && subscribed == 0) {
-        task.subscribe(
-            new SingleObserver<ValueT>() {
-              @Override
-              public void onSubscribe(@NonNull Disposable d) {
-                taskDisposable.compareAndSet(null, d);
-              }
-
-              @Override
-              public void onSuccess(@NonNull ValueT value) {
-                asyncSubject.onNext(value);
-                asyncSubject.onComplete();
-              }
-
-              @Override
-              public void onError(@NonNull Throwable e) {
-                asyncSubject.onError(e);
-              }
-            });
-      }
-
-      return Single.fromObservable(asyncSubject);
-    }
-
-    boolean isTaskTerminated() {
-      return asyncSubject.hasComplete() || asyncSubject.hasThrowable();
-    }
-
-    boolean isTaskDisposed() {
-      return isTaskDisposed.get();
-    }
-
-    void tryDisposeTask() {
-      checkState(!isTaskDisposed(), "disposed");
-      checkState(!isTaskTerminated(), "terminated");
-
-      if (referenceCount.decrementAndGet() == 0) {
-        isTaskDisposed.set(true);
-        asyncSubject.onError(new CancellationException("disposed"));
-
-        Disposable d = taskDisposable.get();
-        if (d != null) {
-          d.dispose();
-        }
-      }
-    }
-  }
-
   /** Returns count of subscribers for a task. */
   public int getSubscriberCount(KeyT key) {
     synchronized (lock) {
-      Execution<ValueT> execution = inProgress.get(key);
-      if (execution != null) {
-        return execution.referenceCount.get();
+      AsyncTask<ValueT> task = inProgress.get(key);
+      if (task != null) {
+        return task.getSubscriberCount();
       }
     }
 
@@ -185,36 +115,21 @@ public final class AsyncTaskCache<KeyT, ValueT> {
 
             finished.remove(key);
 
-            Execution<ValueT> execution =
+            AsyncTask<ValueT> asyncTask =
                 inProgress.computeIfAbsent(
-                    key,
-                    ignoredKey -> {
-                      AtomicInteger subscribeTimes = new AtomicInteger(0);
-                      return new Execution<>(
-                          Single.defer(
-                              () -> {
-                                int times = subscribeTimes.incrementAndGet();
-                                checkState(times == 1, "Subscribed more than once to the task");
-                                return task;
-                              }));
-                    });
+                    key, ignoredKey -> AsyncTask.create(task.toObservable()));
 
-            execution
-                .executeIfNot()
+            Single.fromObservable(asyncTask)
                 .subscribe(
                     new SingleObserver<ValueT>() {
                       @Override
                       public void onSubscribe(@NonNull Disposable d) {
                         emitter.setCancellable(
                             () -> {
-                              d.dispose();
-
-                              if (!execution.isTaskTerminated()) {
-                                synchronized (lock) {
-                                  execution.tryDisposeTask();
-                                  if (execution.isTaskDisposed()) {
-                                    inProgress.remove(key);
-                                  }
+                              synchronized (lock) {
+                                d.dispose();
+                                if (asyncTask.isDisposed()) {
+                                  inProgress.remove(key);
                                 }
                               }
                             });
-- 
2.20.1

